/*
**  usr_funcs.c - 'C' functions required by programs generated by db4glgen
**  Copyright (C) 1989-1995  David A. Snyder
**
**  This library is free software; you can redistribute it and/or
**  modify it under the terms of the GNU Library General Public
**  License as published by the Free Software Foundation; version
**  2 of the License.
**
**  This library is distributed in the hope that it will be useful,
**  but WITHOUT ANY WARRANTY; without even the implied warranty of
**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
**  Library General Public License for more details.
**
**  You should have received a copy of the GNU Library General Public
**  License along with this library; if not, write to the Free
**  Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

#include <malloc.h>
#include <stdio.h>
#include <string.h>


/******************************************************************************
* This function prints whatever is on the screen (including windows).         *
******************************************************************************/

#define bool		char
#define CHAR		short
#define _ATTRIBUTE	(0x7f00)
#define _CHARACTER	(0x00ff)
#define _GRAPHMODE	(0x8000)

typedef struct window {
	short	_cury, _curx;
	short	_maxy, _maxx;
	short	_begy, _begx;
	short	_flags;
	bool	_clear;
	bool	_leave;
	bool	_scroll;
	CHAR	**_y;
	short	*_firstch;
	short	*_lastch;
	short	_attr;
} WINDOW;

typedef struct _efwindow {
	struct _efwindow *upper, *lower;
	int *win;
	int *swin;
	char *formname;
	int *winfrm;
	short rows, columns;
	short promptline;
	short msgline;
	short formline;
	short cmtline;
	short flag;
	short forecolor;
	unsigned long ucount;
} _EFwindow;


extern _EFwindow	*topwin, *botwin, *_Wscreen;
extern WINDOW		*_efbigwin;
extern char	*GB;

fgl_prtscr(arg)
int	arg;
{
	register FILE		*fp;
	register _EFwindow	*scr;
	register WINDOW		*win;
	register CHAR		**line, *data;
	register int	y, x;
	register char	c;
	char	*getenv(), *dbprint;

	if ((dbprint = getenv("DBPRINT")) == NULL)
		dbprint = "lp -s";

	if (topwin == _Wscreen)
		/* the user is looking at the "screen" */

		win = (WINDOW * ) _Wscreen->win;
	else {
		/* the user is looking at the one or more "windows" */

		win = _efbigwin;

		for (scr = botwin; scr != (_EFwindow * )0; 
		    scr  = (_EFwindow * )scr->upper) {
			overwrite((WINDOW * ) scr->win, win);
		}
	}

	if ((fp = popen(dbprint, "w")) != (FILE * )0) {
		for (y = 0, line = win->_y; y < win->_maxy; y++, line++) {
			for (x = 0, data = *line; x < win->_maxx; x++, data++) {
				c = (char) *data & _CHARACTER;

				if ((*data & _GRAPHMODE) && *GB) {
					if (c == GB[0])
						c = '+';
					else if (c == GB[1])
						c = '+';
					else if (c == GB[2])
						c = '+';
					else if (c == GB[3])
						c = '+';
					else if (c == GB[4])
						c = '-';
					else if (c == GB[5])
						c = '|';
				}
				(void)fputc(c, fp);
			}
			(void)fputc('\n', fp);
		}
		(void)pclose(fp);
	}
	return 0;
}


/******************************************************************************
* This function waits for a key on the keyboard to be hit and returns an      *
* INTEGER code for that key.                                                  *
******************************************************************************/

extern short	eflastkey;

fgl_getkey(arg)
int	arg;
{
	extern short	_acckey;
	short	keyhit;

	eflastkey = ((keyhit = rgetkey()) == _acckey) ? 2016 : keyhit;
	clrmsg();
	retlong((long) eflastkey);
	return(1);
}


/******************************************************************************
* These four(4) functions handle the dynamic rowid array for all standard     *
* 4GL screens.                                                                *
******************************************************************************/

static long	*ptr;

i_rowid_s(arg)
int	arg;
{
	if ((ptr = (long *)malloc(sizeof(long))) != NULL)
		retint(0);
	else
		retint(1);
	return(1);

}


m_rowid_s(arg)
int	arg;
{
	int	i, q_cur, q_cnt;

	popint(&q_cnt);
	popint(&q_cur);

	for (i = q_cur; i < q_cnt; i++)
	    ptr[i] = ptr[i+1];

	return(0);
}


r_rowid_s(arg)
int	arg;
{
	int	pos;

	popint(&pos);
	retint(ptr[pos]);
	return(1);
}


s_rowid_s(arg)
int	arg;
{
	int	size;

	popint(&size);
	if ((ptr = (long *)realloc((char *)ptr, (unsigned)(size + 1) * sizeof(long))) != NULL)
		retint(0);
	else
		retint(1);
	return(1);
}


w_rowid_s(arg)
int	arg;
{
	int	pos, value;

	popint(&value);
	popint(&pos);
	ptr[pos] = value;
	return(0);
}


